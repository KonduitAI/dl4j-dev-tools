# ND4J Op Definitions and Code Generation
This project contains the ND4J Op definitions, the DSL (Domain Specific Language) that is used for those definitions and
code generators that use those definitions to create the actual Java code that is used to use the defined operations.


## Why define ops externally?
As we started to support SameDiff, we also started to introduce inconsistencies between SameDiff and ND4J. Even though 
both of those libraries use the same underlying implementations for operations, there are both small and large
differences in the API that we provide for them. Sometimes, we have provided an official API only for one usage, and not
the other. And very often the documentation for a single op is in many different places.

In the future we want to support other programming languages with libnd4j, and provide more ways to use our C++ backend.
This would only increase the aforementioned problems.
 
The root of all of those problems, is that Ops are used across different environments, and there is no single way of 
defining them with an enforced interface.


## How does this project help with enforcing a single consistent interface for ops?
The solution we propose, is to define the operations separately, and then generate the necessary API code for them. All
of the generated code is to be considered untouchable, editing it will result in the changes being overwritten sooner
rather than later.

The combination of external op definition and code generation, opens up many opportunities for us. The first one being
that we can easily create consistent APIs for both ND4J and SameDiff in Java. But, looking into the future, we can also 
create those APIs for other programming languages like Python, Swift, or even C#. We can even go beyond programming
languages, and use the op definitions to create better documentation than what JavaDoc or similar might support out of
the box.

## Maintenance
This project is currently maintained by Paul Dubs, with feedback often collected from raver119 and Alex Black.
 
## Current Status
At the moment we still focus on nailing down an easily readable and contribution friendly DSL for op definition and code
generation that can replace namespace definitions. This means that at the moment we still rely on the pre-existing Op
definition classes that already exist in ND4J.

## Roadmap
* Replace Bitwise and Random namespaces with autogenerated code – In progress.
* Implement a convenient CLI tool.
* Define all Ops using the DSL. 
* Replace all namespace definitions in ND4J / SameDiff with automatically generated ones
* Replace all Op classes with automatically generated ones.

# Usage
Pre-requisites:
* JDK 8 or higher
* Maven 3.3 or higher

TODO: Show usage output of the project itself

TODO: Show how to use from mvn

TODO:add picocli based cli to run things: Output ALL namespaces to specific directory; Output selected namespace to
specific directory; Output specific namespace to stdout; Use specified generator instead of default

# Code structure
The project is implemented using a mix of Java and Kotlin. The DSL definition and the accompanying data structures are
implemented in Kotlin. At the moment the code generators are implemented in Java, in order to allow people who are not
fluent in Kotlin, but know Java to be able to contribute to the code generators.

The source code for this project is structured a bit different that what you would typically see in a Java or Kotlin
project. When you take a look inside the `src/main` directory, you will find 4 sub-directories. 

The `java` and `kotlin` directories contain Java and Kotlin code respectively. 

In order to not confuse op definitions with the machinery that allows them to be defined in that way, ops are kept in a
separate folder called `ops`.
 
Because we use JavaPoet for Java code generator implementation, we also have yet another folder called `stubs`. That
folder contains stub classes, that are used to reference other classes available in ND4J. These stub classes are
intentionally left empty, as JavaPoet only requires them for naming and automatically creating proper imports. We use
stub classes instead of depending on the actual nd4j API in order to break a cyclic dependency that would otherwise be
created (i.e. in order to be able to generate code for ND4J, we would need an already compiled nd4j to be available).
**Note:** If something is stubbed here and is moved in ND4J, then it also has to be moved to the appropriate place here,
otherwise the generated code will be wrong.

The `adr` folder contains “Architecture Decision Records”. These files give you more insight into the “why” of some of
the bigger decisions within this project.

# DSL for Op Definition
Ops are defined using a DSL that is implemented in Kotlin. This means that other than the DSL, as defined in the
following, you can also use all of Kotlin when defining Ops. However, doing things the obvious and clearly
understandable way is better than coming up with a clever way, so prefer to use the DSL as described if unsure.

```kotlin
val mathNs = Namespace("math") {
    Op("add") {
        javaPackage = "org.nd4j.linalg.api.ops.impl.transforms.pairwise.arithmetic"

        Input(NUMERIC, "x") { optional = true; description = "First input to add" }
        Input(NUMERIC,"y") { count = AtLeast(1); description = "Second input to add" }
        Arg(INT,"shape") { count = AtLeast(1); description = "shape" }


        Output(NUMERIC, "z") { description = "Output (x+y)" }

        Doc(Language.ANY, DocScope.ALL) {
            """
            (From AddOp) Add op doc text that will appear everywhere - classes, constructors, op creators
            """.trimIndent()
        }
        Doc(Language.ANY, DocScope.CLASS_DOC_ONLY) {
            "Add op doc text that will appear in all class docs (javadoc etc)"
        }
        Doc(Language.ANY, DocScope.CONSTRUCTORS_ONLY) {
            "Add op doc text for constructors only"
        }

    }
}
```

This example shows how a namespace is defined. Namespaces are at the top layer, and ops can only be defined within the
context of a namespace. This example namespace contains only a single op, called “add”. If we wanted to add another op,
we would simply add it below the first.

As you can see, every op has to have a name, if you try to create one without a name, you will get a compile error. 
Within the context of the op, we first set in which java package the op class can be found in, then define its inputs, 
arguments and outputs and finally add some free form documentation about what that op is doing.

Like with the op itself, the inputs, arguments and outputs all have to have a name, but unlike the op, they also require
a type. Within their context, you can set a description and a count of how many parameters they can take respectively.
 
If an input, argument or output take anything else than exactly 1, they will be treated as arrays. Typically you would
use this to define ops like `concat` which can take multiple input tensors or ops that might take shape arguments.

## Examples
The following shows how a typical op definition looks like and how the generated Java code may look.

An op might be defined like this:

```kotlin
Op("binomial") {
    javaPackage = "org.nd4j.linalg.api.ops.random.custom"
    Arg(INT, "nTrials") { description = "Number of trials parameter for the binomial distribution" }
    Arg(FLOATING_POINT, "p") { description = "Probability of success for each trial" }
    Arg(INT, "shape") { count = AtLeast(1); description = "Shape of the new random SDVariable, as a 1D array" }

    Output(NUMERIC, "output") { description = "new random SDVariable, where values are randomly sampled according to a Binomial distribution" }

    Doc(Language.ANY, DocScope.ALL) {
        """
        Generate a new random SDVariable, where values are randomly sampled according to a Binomial distribution,
        with the specified number of trials and probability.
        """.trimIndent()
    }
}
```

The java code generator will create a method like the following for it:
```java
  /**
   * Generate a new random SDVariable, where values are randomly sampled according to a Binomial distribution,
   * with the specified number of trials and probability.
   *
   * @param nTrials Number of trials parameter for the binomial distribution
   * @param p Probability of success for each trial
   * @param shape Shape of the new random SDVariable, as a 1D array (Size: AtLeast(min=1))
   * @return output new random SDVariable, where values are randomly sampled according to a Binomial distribution (NUMERIC type)
   */
  public static INDArray binomial(long nTrials, double p, long... shape) {
    Preconditions.checkArgument(shape.length >= 1, "shape has incorrect count. Expected: AtLeast(min=1)");
    return Nd4j.exec(new org.nd4j.linalg.api.ops.random.custom.BinomialOp(nTrials, p, shape))[0];
  }
```

Or an op with some more constraints:

```kotlin
Op("and") {
    javaPackage = "org.nd4j.linalg.api.ops.impl.transforms.custom"
    val x = Input(INT, "x") { description = "First input array" }
    val y = Input(INT, "y") { description = "Second input array" }
    Constraint("Must be same types"){ sameType(x, y) }
    Constraint("Must have broadcastable shapes"){ broadcastableShapes(x, y) }

    Output(INT, "output"){ description = "Bitwise AND array" }

    Doc(Language.ANY, DocScope.ALL){
        """
        Bitwise AND operation. Supports broadcasting.
        """.trimIndent()
    }
}
```

will be converted to java like this:

```java
  /**
   * Bitwise AND operation. Supports broadcasting.
   *
   * Inputs must satisfy the following constraints: 
   * Must be same types: isSameType(x, y)
   * Must have broadcastable shapes: isBroadcastableShapes(x, y)
   *
   * @param x First input array (INT type)
   * @param y Second input array (INT type)
   * @return output Bitwise AND array (INT type)
   */
  public static INDArray and(INDArray x, INDArray y) {
    NDValidation.validateInteger("and", x);
    NDValidation.validateInteger("and", y);
    Preconditions.checkArgument(isSameType(x, y), "Must be same types");
    Preconditions.checkArgument(isBroadcastableShapes(x, y), "Must have broadcastable shapes");
    return Nd4j.exec(new org.nd4j.linalg.api.ops.impl.transforms.custom.AndOp(x, y))[0];
  }
```

# Full DSL Description
## Namespace

    fun NamespaceName() = Namespace(“name”){ /* Op definitions in namespace context */}
    
Defines a namespace.

## Op
Only available within a namespace context

    Op(“opName”) { /* op properties in op context */ }
    val opName = Op(“opName”) { /* op properties in op context */ }
    val anotherOp = Op(“anotherOp”, opName) { /* op properties in op context */ }
    
Every op requires a namespace unique op name.
 
When defining an op, you can assign it to a variable in order to be able to reference it later on. You might want to do
this to inherit the properties of that op when defining another op.
 
Note: When using op inheritance, you will replace inputs, args, outputs and documentation as soon as you define one of
them. If you want to change one input, you will have to define all of the inputs. If you want to change one argument,
you will have to define all arguments.
 
Note: Op inheritance is only available within a namespace. Allowing cross-namespace inheritance would violate the 
principle that we want to keep Op definitions as readable as possible.

### Op properties
* `libnd4jName` (String): The name the op has in libnd4j. Default: same as opName
* `isAbstract` (Boolean): Flag that makes ops abstract, i.e. they are only allowed to be inherited from. No code shall be generated for abstract Ops.
* `javaPackage` (String): Package where the Op is to be found in the java implementation.


## Input
Only available within an op context

    Input(FLOATING_POINT, “b”){ /* input properties in input context */ }
    val a = Input(INT, “a”){ /* input properties in input context */ }
    
Inputs represent tensors. They are what the op will work on.

Every input requires a data type (either `INT`, `FLOATING_POINT`, `NUMERIC` or `BOOLEAN`) and an op unique name.

When defining an input, you can assign it to a variable in order to be able to reference it later on. You might want to
do this when defining constraints.
 
### Input properties
* `optional` (Boolean): Flag that marks this input as optional.
* `description` (String): A short description what this input represents. Setting this is recommended.
* `count` (Count): Can take one of `Exactly(n)`; `AtLeast(n)`; `AtMost(n)`; `Range(from, to)`

## Argument
Only available within an op context

    Arg(FLOATING_POINT, “b”){ /* Arg properties in arg context */ }
    val a = Arg(INT, “a”){ /* Arg properties in arg context */ }
    
Args represent arguments. They modify how the op works on its inputs.

Every arg requires a data type (either `INT`, `FLOATING_POINT`, `NUMERIC` or `BOOLEAN`) and an op unique name.

When defining an arg, you can assign it to a variable in order to be able to reference it later on. You might want to do
this when defining constraints.
 
### Argument properties
* `optional` (Boolean): Flag that marks this input as optional.
* `description` (String): A short description what this argument represents. Setting this is recommended.
* `count` (Count): Can take one of `Exactly(n)`; `AtLeast(n)`; `AtMost(n)`; `Range(from, to)`

## Output
Only available within an op context

    Output(FLOATING_POINT, “b”){ /* Arg properties in arg context */ }

Every output requires a data type (either `INT`, `FLOATING_POINT`, `NUMERIC` or `BOOLEAN`) and an op unique name.

While outputs can be assigned to a variable, there is no intended use-case for it. In contrast to inputs and args, 
outputs can not be used in constraints.

### Output properties
* `description` (String): A short description what this argument represents. Setting this is recommended.


## Documentation
Only available within an op context

    Doc(Language.ANY, DocScope.ALL){
        “”” Some documentation
        It can be multiline. And indented.
        “””.trimIndent()
    }
    
Documentation can be language specific, and can be set to be only given at specific places. The documentation itself is
given as a string. Because Kotlin supports multiline strings along with proper indentation, we are using them directly
here.

Note: At the moment we are only creating java code, so the documentation can use JavaDoc syntax.

You can have multiple Doc definitions; they are treated as additive.

Any instances of the following values will be replaced when generating code:

* `%OPNAME%` -> operation name ("Add", "Sub", etc)
* `%LIBND4J_OPNAME%` -> libnd4j op name ("add", "sub", etc)
* `%INPUT_TYPE%` -> input / output type depending on the generated api, i.e. `SDVariable` for SameDiff and `INDArray`
  for ND4J

See `DocTokens` class for more details. 

## Constraints
Only available within an op context.

    Constraint("Error Message if constraint isn't satisfied"){ /* constraint definition */ }
    BackendConstraint("Error Message if constraint isn't satisfied"){ /* constraint definition */ }

Many ops expect their inputs and arguments to satisfy some specific rules. Those rules can be expressed with the
constraint system.

Constraints are to be enforced within the frontend language, while BackendConstraints are currently only to be used as
a part of the documentation. They will be enforced within the C++ backend, so there is no point in double checking them.

There is a system in place to define even complex constraints for inputs and arguments.

In a constraint definition, you can reference inputs and arguments directly, if they are previously assigned to
a variable using `val name = Input(...)`. Inside the Constraint block, you can use the following operations:

* `eq`: Compare equality (applicable to numbers and booleans), e.g. `x eq 7`, `x eq true`
* `neq`: Compare inequality (applicable to numbers and booleans), e.g. `x neq 3`, `x neq true`
* `lt`, `lte`: less than, less than equal (applicable to numbers), e.g. `x lt 3`, `x lte 4`
* `gt`, `gte`: greater than, grater than equal (applicable to numbers), e.g. `x gt 5`, `x gte 6`
* `and`: combine two comparisons where both have to be true, e.g. `(x eq 8) and (y lt 3)`
* `or`: combine two comparisons where one has to be true, e.g. `(x eq 8) or (y eq true)`
* `all`: combine N comparisons where all have to be true, e.g. `all(x eq 8, y lt 3, z eq true)`
* `some`: combine N comparisons where at least one has to be true, e.g. `some(x eq 8, y lt 3, z eq true)`
* `not`: negates a comparison, e.g. `not(x eq 3)`

In addition to those operations, you also get access to some more complex constraints:
* `sameType(...)`: true if all given inputs are the same type, e.g. `sameType(x,y,z)`
* `sameShape(...)`: true if all given inputs have the same shape, e.g. `sameShape(x,y,z)`
* `broadcastableShapes(...)`: true if all given inputs have broadcast compatible shapes, e.g. `broadcastableShapes(x,y,z)`

Inputs also get some additional methods on them to define useful constraints:
* `input.rank()`: Rank of the given input
* `input.sizeAt(i)`: size of the given input at the i-th dimension
* `input.isScalar()`: Short hand for `x.rank() == 1`

### Examples
Some examples of constraints, and what they evaluate to. The example code contains a little bit of context.

```kotlin
val x = Input(INT, "x") { description = "First input array" }
val y = Input(INT, "y") { description = "Second input array" }
Constraint("foo bar"){
   x.sizeAt(7) eq 7 and y.isScalar()
}
```

will evaluate to:
```java
    Preconditions.checkArgument((x.sizeAt(7) == 7) && (y.rank() == 1), "foo bar");
```

More examples (only the constraint itself, without context code):

#### Some
```kotlin
some(input.rank() eq 3, input.sizeAt(2) gte 7, input.sizeAt(4) lt 5)
```
turns to:
```java
((x.rank() == 3) || (x.sizeAt(2) >= 7)) || (x.sizeAt(4) < 5)
```

# Contributing to this project
If you want to contribute to this project other than by adding or improving op definitions, the following sections might
be of special interest to you.

## Extending the DSL
he DSL is implemented using Kotlin’s type-safe builders feature 
(see https://kotlinlang.org/docs/reference/type-safe-builders.html). The basic principle is that functions calls can
receive blocks that can be executed in a specified context. When combined with the fact that we are just looking to
create an object graph that is then going to be used as input to the code generators, this allows us to create a very 
feature rich DSL without actually having to write a lot of code to support it.

Most of the DSL specific code can be found in `src/kotlin/org/nd4j/codegen/dsl/OpBuilder.kt`. The actual class
definitions for the object graph we are building, can be found in `src/kotlin/org/nd4j/codegen/api`. 

If you want to add just a simple field to one of the objects, it is usually enough to directly add it to the particular
class.

If you want to add a specific section to the op definition, i.e. a section like Input or Doc, you will have to add both
the class for the object that it is going to be creating, as well as a function within OpBuilder.kt to create and
register that section within the op.
 
**Note:** When you extend the DSL you will most likely also have to update all code generators to support the feature 
you have added.
 
## Adding / extending code generators
Code generators can be written in either Java or Kotlin. Java has the advantage that more people will have experience in
using it. Kotlin has the advantage of more convenient syntax, especially for plain string manipulation and when dealing
with Enums and fixed sets of subclasses (called sealed classes in Kotlin).

All generators have to implement the `org.nd4j.codegen.api.generator.Generator` interface. For automatic detection by
the CLI tool, they should also be within the `org.nd4j.codegen.impl.LANGUAGE` package, where `LANGUAGE` is the actual
language that they generate.

Code generators can also use an auxiliary generator for constraint generation. Those auxiliary generators, have to
implement ` org.nd4j.codegen.api.generator.ConstraintCodeGenerator` interface.